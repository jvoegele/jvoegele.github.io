<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Contract Programming in Clojure</title>
</head>
<body>
<p>In his landmark book, <i><a href="http://www.amazon.com/wintermute/dp/0136291554/" target="_blank">Object-Oriented Software Construction</a></i>&nbsp;(2nd ed. 1997), Bertrand Meyer popularized the idea of Design By Contract (TM), an approach to the design and construction of software using formal specification methods to describe the behavior of systems and modules. Ever since reading this book, which uses the Eiffel programming language as its notation, I've lamented the fact that more mainstream programming languages do provide any built-in support for contract programming. Digital Mars' <a href="http://dlang.org/" target="_blank"><i>D</i>&nbsp;programming language</a> is one of the very few languages to fully support contracts that also has had a book published about it (Andrei Alexandrescu's <i><a href="http://www.amazon.com/wintermute/dp/0321635361/" target="_blank">The D Programming Language</a></i>, 2010).</p>

  <p>I was pleased to discover, then, that (beginning with the 1.1 release) Clojure has rudimentary support for contract programming built in, and more advanced support available via external libraries. This blog post will introduce these features and discuss the extent to which Design By Contract can be employed in Clojure.</p>

<h3>Function Preconditions and Postconditions</h3>
<p>To quote Meyer, &ldquo;the precondition states the properties that must hold whenever the [function] is called; the postcondition states the properties that the [function] guarantees when it returns.&rdquo;</p>
</body>
</html>
